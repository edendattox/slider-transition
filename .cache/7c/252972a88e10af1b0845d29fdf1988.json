{"id":"js/shaders/fragment.glsl","dependencies":[{"name":"E:\\three.js-stuff\\6 - slider\\package.json","includedInParent":true,"mtime":1621750794010}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\nuniform float time;\\nuniform sampler2D noiseTexture;\\nuniform float progress;\\nuniform vec4 resolution;\\nvarying vec2 vUv;\\nvarying vec3 vNormal;\\nvarying vec3 vPosition;\\nvarying vec2 vScreenSpace;\\nvarying vec3 vViewDirection;\\n\\nfloat PI = 3.141592653589793238;\\n\\nfloat threshold(float edge0, float edge1, float x) {\\n        return clamp( (x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n}\\n\\nfloat hash(vec3 p) // replace this by something better\\n{\\n        p = fract( p*0.3183099+.1 );\\n        p *= 17.0;\\n        return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\\n}\\n\\nfloat noise( in vec3 x )\\n{\\n        vec3 i = floor(x);\\n        vec3 f = fract(x);\\n        f = f*f*(3.0-2.0*f);\\n\\n        return mix(mix (mix( hash(i+vec3 (0,0,0)),\\n                hash (i+vec3(1,0,0)), f.x),\\n                mix( hash(i+vec3(0,1,0)),\\n                hash (i+vec3(1,1,0)),f.x),f.y),\\n                mix (mix( hash(i+vec3(0,0,1)),\\n                hash (i+vec3(1,0,1)),f.x),\\n                mix( hash(i+vec3 (0,1,1)),\\n                hash (i+vec3(1,1,1)),f.x),f.y),f.z);\\n}\\n\\nfloat rand (float n){return fract(sin(n) * 43758.5453123);}\\n\\nfloat noise(float p) {\\n        float fl = floor(p);\\n        float fc = fract(p);\\n        return mix(rand (fl), rand(fl + 1.0), fc);\\n}\\n\\nvoid main() {\\n\\n  float light = dot(vNormal, normalize(vec3( 1.)));\\n  \\n\\n  // noise \\n  float ttt = texture2D(noiseTexture, 0.5*(vScreenSpace + 1.)).r;\\n  // strokes\\n \\n  float stroke = cos((vScreenSpace.x - vScreenSpace.y)*800.);\\n\\n  float smallnoise = noise(500.*vec3(vScreenSpace, 1.));\\n  float bignoise = noise(5.*vec3(vScreenSpace, 4.));\\n  float fresnel = 1. - dot(vNormal, -vViewDirection);\\n  fresnel = fresnel*fresnel*fresnel;\\n\\n  stroke += (smallnoise*2. -1.) + (bignoise*2. - 1.) ;\\n\\n  // light += (bignoise*2. - 1.);\\n\\n  stroke = 1. - smoothstep(1. * light - 0.2, 1. * light + 0.2, stroke) - 0.5*fresnel;\\n  \\n\\n  // changes the color of the object\\n  // smoothstep is to flawlessly animate\\n  float stroke1 = 1. - smoothstep(2. * light - 3., 2. * light + 3., stroke) ;\\n  \\n  float temp = progress;\\n  temp += (2.*ttt - 1.) * 0.2;\\n\\n  // getting the distance form center from the object\\n  float distanceFromCenter = length(vScreenSpace);\\n  temp = smoothstep(temp - 0.005, temp, distanceFromCenter);\\n\\n  gl_FragColor = vec4(vScreenSpace, 0., 1.);\\n  gl_FragColor = vec4(vNormal, 1.);\\n  float finalLook = mix(stroke1, stroke, temp);\\n  gl_FragColor = vec4(vec3(finalLook), 1.);\\n  // gl_FragColor = vec4(vec3(distanceFromCenter), 1.);\\n  // gl_FragColor = vec4(vec3(temp), 1.);\\n  // gl_FragColor = vec4(vec3(progress), 1.);\\n  // gl_FragColor = vec4(vec3(light), 1.);\\n\\n}\\n\\n// grey textures\\n\\n/*\\n*  so if we change light in stroke smooth step we will be getting ther color between whtie grey\\n*/ \\n\\n  // float light = dot(vNormal, normalize(vec3(1.)));\\n\\n  // // strokes\\n \\n  // float stroke = cos((vScreenSpace.x - vScreenSpace.y)*500.);\\n\\n  // float smallnoise = noise(500.*vec3(vScreenSpace, 1.));\\n  // float bignoise = noise(5.*vec3(vScreenSpace, 1.));\\n\\n  // stroke += (smallnoise*2. -1.) + (bignoise*2. - 1.);\\n\\n  // light += (bignoise*2. - 1.);\\n\\n  // stroke = smoothstep(light - 1., light + 3. ,stroke);\\n\\n  // gl_FragColor = vec4(vScreenSpace, 0., 1.);\\n  // gl_FragColor = vec4(vNormal, 1.);\\n  // // gl_FragColor = vec4(vec3(light), 1.);\\n  // gl_FragColor = vec4(vec3(stroke), 1.);\\n\\n\";"},"sourceMaps":{"js":{"mappings":[{"name":"module","generated":{"line":1,"column":0},"source":"js/shaders/fragment.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":6},"source":"js/shaders/fragment.glsl","original":{"line":1,"column":6}},{"name":"exports","generated":{"line":1,"column":7},"source":"js/shaders/fragment.glsl","original":{"line":1,"column":7}},{"generated":{"line":1,"column":14},"source":"js/shaders/fragment.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":17},"source":"js/shaders/fragment.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":3445},"source":"js/shaders/fragment.glsl","original":{"line":1,"column":0}}],"sources":{"js/shaders/fragment.glsl":"module.exports=\"#define GLSLIFY 1\\nuniform float time;\\nuniform sampler2D noiseTexture;\\nuniform float progress;\\nuniform vec4 resolution;\\nvarying vec2 vUv;\\nvarying vec3 vNormal;\\nvarying vec3 vPosition;\\nvarying vec2 vScreenSpace;\\nvarying vec3 vViewDirection;\\n\\nfloat PI = 3.141592653589793238;\\n\\nfloat threshold(float edge0, float edge1, float x) {\\n        return clamp( (x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n}\\n\\nfloat hash(vec3 p) // replace this by something better\\n{\\n        p = fract( p*0.3183099+.1 );\\n        p *= 17.0;\\n        return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\\n}\\n\\nfloat noise( in vec3 x )\\n{\\n        vec3 i = floor(x);\\n        vec3 f = fract(x);\\n        f = f*f*(3.0-2.0*f);\\n\\n        return mix(mix (mix( hash(i+vec3 (0,0,0)),\\n                hash (i+vec3(1,0,0)), f.x),\\n                mix( hash(i+vec3(0,1,0)),\\n                hash (i+vec3(1,1,0)),f.x),f.y),\\n                mix (mix( hash(i+vec3(0,0,1)),\\n                hash (i+vec3(1,0,1)),f.x),\\n                mix( hash(i+vec3 (0,1,1)),\\n                hash (i+vec3(1,1,1)),f.x),f.y),f.z);\\n}\\n\\nfloat rand (float n){return fract(sin(n) * 43758.5453123);}\\n\\nfloat noise(float p) {\\n        float fl = floor(p);\\n        float fc = fract(p);\\n        return mix(rand (fl), rand(fl + 1.0), fc);\\n}\\n\\nvoid main() {\\n\\n  float light = dot(vNormal, normalize(vec3( 1.)));\\n  \\n\\n  // noise \\n  float ttt = texture2D(noiseTexture, 0.5*(vScreenSpace + 1.)).r;\\n  // strokes\\n \\n  float stroke = cos((vScreenSpace.x - vScreenSpace.y)*800.);\\n\\n  float smallnoise = noise(500.*vec3(vScreenSpace, 1.));\\n  float bignoise = noise(5.*vec3(vScreenSpace, 4.));\\n  float fresnel = 1. - dot(vNormal, -vViewDirection);\\n  fresnel = fresnel*fresnel*fresnel;\\n\\n  stroke += (smallnoise*2. -1.) + (bignoise*2. - 1.) ;\\n\\n  // light += (bignoise*2. - 1.);\\n\\n  stroke = 1. - smoothstep(1. * light - 0.2, 1. * light + 0.2, stroke) - 0.5*fresnel;\\n  \\n\\n  // changes the color of the object\\n  // smoothstep is to flawlessly animate\\n  float stroke1 = 1. - smoothstep(2. * light - 3., 2. * light + 3., stroke) ;\\n  \\n  float temp = progress;\\n  temp += (2.*ttt - 1.) * 0.2;\\n\\n  // getting the distance form center from the object\\n  float distanceFromCenter = length(vScreenSpace);\\n  temp = smoothstep(temp - 0.005, temp, distanceFromCenter);\\n\\n  gl_FragColor = vec4(vScreenSpace, 0., 1.);\\n  gl_FragColor = vec4(vNormal, 1.);\\n  float finalLook = mix(stroke1, stroke, temp);\\n  gl_FragColor = vec4(vec3(finalLook), 1.);\\n  // gl_FragColor = vec4(vec3(distanceFromCenter), 1.);\\n  // gl_FragColor = vec4(vec3(temp), 1.);\\n  // gl_FragColor = vec4(vec3(progress), 1.);\\n  // gl_FragColor = vec4(vec3(light), 1.);\\n\\n}\\n\\n// grey textures\\n\\n/*\\n*  so if we change light in stroke smooth step we will be getting ther color between whtie grey\\n*/ \\n\\n  // float light = dot(vNormal, normalize(vec3(1.)));\\n\\n  // // strokes\\n \\n  // float stroke = cos((vScreenSpace.x - vScreenSpace.y)*500.);\\n\\n  // float smallnoise = noise(500.*vec3(vScreenSpace, 1.));\\n  // float bignoise = noise(5.*vec3(vScreenSpace, 1.));\\n\\n  // stroke += (smallnoise*2. -1.) + (bignoise*2. - 1.);\\n\\n  // light += (bignoise*2. - 1.);\\n\\n  // stroke = smoothstep(light - 1., light + 3. ,stroke);\\n\\n  // gl_FragColor = vec4(vScreenSpace, 0., 1.);\\n  // gl_FragColor = vec4(vNormal, 1.);\\n  // // gl_FragColor = vec4(vec3(light), 1.);\\n  // gl_FragColor = vec4(vec3(stroke), 1.);\\n\\n\";"},"lineCount":null}},"error":null,"hash":"15932d487e36f0971601c26409373cf9","cacheData":{"env":{}}}